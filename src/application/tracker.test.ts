import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

vi.mock('@actions/core', () => ({
  getInput: vi.fn(),
  info: vi.fn(),
  warning: vi.fn(),
  setFailed: vi.fn(),
  debug: vi.fn(),
  setOutput: vi.fn(),
}));

vi.mock('@actions/github', () => ({
  getOctokit: vi.fn(() => ({})),
}));

vi.mock('@config/loader', () => ({
  loadConfig: vi.fn(),
}));

vi.mock('@domain/comparison', () => ({
  compareStars: vi.fn(),
  createSnapshot: vi.fn(),
}));

vi.mock('@domain/formatting', () => ({
  deltaIndicator: vi.fn(),
}));

vi.mock('@domain/notification', () => ({
  shouldNotify: vi.fn(),
}));

vi.mock('@domain/snapshot', () => ({
  getLastSnapshot: vi.fn(),
  addSnapshot: vi.fn(),
}));

vi.mock('@i18n', () => ({
  getTranslations: vi.fn(),
  interpolate: ({
    template,
    params,
  }: {
    template: string;
    params: Record<string, string | number>;
  }) =>
    template.replace(/\{(\w+)\}/g, (_, key: string) =>
      key in params ? String(params[key]) : `{${key}}`,
    ),
}));

vi.mock('@infrastructure/github/filters', () => ({
  getRepos: vi.fn(),
}));

vi.mock('@infrastructure/git/worktree', () => ({
  initializeDataBranch: vi.fn(),
  cleanup: vi.fn(),
}));

vi.mock('@infrastructure/persistence/storage', () => ({
  readHistory: vi.fn(),
  writeHistory: vi.fn(),
  writeReport: vi.fn(),
  writeBadge: vi.fn(),
  commitAndPush: vi.fn(),
}));

vi.mock('@infrastructure/notification/email', () => ({
  getEmailConfig: vi.fn(),
  sendEmail: vi.fn(),
}));

vi.mock('@presentation/badge', () => ({
  generateBadge: vi.fn(),
}));

vi.mock('@presentation/html', () => ({
  generateHtmlReport: vi.fn(),
}));

vi.mock('@presentation/markdown', () => ({
  generateMarkdownReport: vi.fn(),
}));

import * as core from '@actions/core';
import { loadConfig } from '@config/loader';
import { compareStars, createSnapshot } from '@domain/comparison';
import { deltaIndicator } from '@domain/formatting';
import { shouldNotify } from '@domain/notification';
import { addSnapshot, getLastSnapshot } from '@domain/snapshot';
import { getTranslations } from '@i18n';
import { cleanup, initializeDataBranch } from '@infrastructure/git/worktree';
import { getRepos } from '@infrastructure/github/filters';
import { getEmailConfig, sendEmail } from '@infrastructure/notification/email';
import {
  commitAndPush,
  readHistory,
  writeBadge,
  writeHistory,
  writeReport,
} from '@infrastructure/persistence/storage';
import { generateBadge } from '@presentation/badge';
import { generateHtmlReport } from '@presentation/html';
import { generateMarkdownReport } from '@presentation/markdown';
import { trackStars } from './tracker';

const defaultConfig = {
  visibility: 'all' as const,
  includeArchived: false,
  includeForks: false,
  excludeRepos: [],
  onlyRepos: [],
  minStars: 0,
  dataBranch: 'star-data',
  maxHistory: 52,
  sendOnNoChanges: false,
  includeCharts: true,
  locale: 'en' as const,
  notificationThreshold: 0,
};

const defaultSummary = {
  totalStars: 100,
  totalPrevious: 90,
  totalDelta: 10,
  newStars: 12,
  lostStars: 2,
  changed: true,
};

const defaultRepos = [
  {
    owner: 'user',
    name: 'repo-a',
    fullName: 'user/repo-a',
    private: false,
    archived: false,
    fork: false,
    stars: 60,
  },
  {
    owner: 'user',
    name: 'repo-b',
    fullName: 'user/repo-b',
    private: false,
    archived: false,
    fork: false,
    stars: 40,
  },
];

const defaultHistory = { snapshots: [] };
const defaultSnapshot = { timestamp: '2026-01-01T00:00:00Z', totalStars: 100, repos: [] };
const defaultUpdatedHistory = { snapshots: [defaultSnapshot] };
const defaultResults = { repos: [], summary: defaultSummary };
const defaultTranslations = {
  badge: { totalStars: 'Total Stars' },
  report: {
    title: 'Star Report',
    total: 'Total',
    change: 'Change',
    comparedTo: 'Compared to',
    firstRun: 'First run',
    repositories: 'Repositories',
    stars: 'Stars',
    starsCount: '{count} stars',
    trend: 'Trend',
    newRepositories: 'New',
    removedRepositories: 'Removed',
    removedRepoText: '{name} â€” was {count} stars',
    summary: 'Summary',
    starsGained: 'Stars gained',
    starsLost: 'Stars lost',
    netChange: 'Net change',
    starTrend: 'Star Trend',
    starHistory: 'Star History',
    topRepositories: 'Top Repos',
    byRepository: 'By Repo',
    badges: { new: 'NEW' },
  },
  email: {
    subject: 'Star Report',
    subjectLine: '{subject}: {totalStars} ({delta})',
    defaultFrom: 'noreply@example.com',
  },
  trends: { up: 'Up', down: 'Down', stable: 'Stable' },
  footer: { generated: 'Generated by {project} on {date}', madeBy: 'Made by {author}' },
};

function setupDefaults() {
  vi.mocked(core.getInput).mockReturnValue('fake-token');
  vi.mocked(loadConfig).mockReturnValue(defaultConfig);
  vi.mocked(getTranslations).mockReturnValue(defaultTranslations);
  vi.mocked(getRepos).mockResolvedValue(defaultRepos);
  vi.mocked(initializeDataBranch).mockReturnValue('.star-data');
  vi.mocked(readHistory).mockReturnValue(defaultHistory);
  vi.mocked(getLastSnapshot).mockReturnValue(null);
  vi.mocked(compareStars).mockReturnValue(defaultResults);
  vi.mocked(deltaIndicator).mockReturnValue('+10');
  vi.mocked(generateMarkdownReport).mockReturnValue('# MD Report');
  vi.mocked(generateHtmlReport).mockReturnValue('<p>HTML</p>');
  vi.mocked(generateBadge).mockReturnValue('<svg>badge</svg>');
  vi.mocked(createSnapshot).mockReturnValue(defaultSnapshot);
  vi.mocked(addSnapshot).mockReturnValue({ ...defaultUpdatedHistory });
  vi.mocked(shouldNotify).mockReturnValue(true);
  vi.mocked(getEmailConfig).mockReturnValue(null);
  vi.mocked(sendEmail).mockResolvedValue(true);
}

describe('trackStars', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    setupDefaults();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('runs the full happy path', async () => {
    await trackStars();

    expect(loadConfig).toHaveBeenCalled();
    expect(getRepos).toHaveBeenCalled();
    expect(initializeDataBranch).toHaveBeenCalledWith('star-data');
    expect(readHistory).toHaveBeenCalledWith('.star-data');
    expect(compareStars).toHaveBeenCalled();
    expect(generateMarkdownReport).toHaveBeenCalled();
    expect(generateHtmlReport).toHaveBeenCalled();
    expect(generateBadge).toHaveBeenCalled();
    expect(writeHistory).toHaveBeenCalled();
    expect(writeReport).toHaveBeenCalled();
    expect(writeBadge).toHaveBeenCalled();
    expect(commitAndPush).toHaveBeenCalled();
    expect(core.setOutput).toHaveBeenCalled();
  });

  it('sets empty outputs and returns early when no repos match', async () => {
    vi.mocked(getRepos).mockResolvedValue([]);

    await trackStars();

    expect(core.warning).toHaveBeenCalledWith('No repositories matched the configured filters');
    expect(core.setOutput).toHaveBeenCalledWith('total-stars', '0');
    expect(core.setOutput).toHaveBeenCalledWith('stars-changed', 'false');
    expect(core.setOutput).toHaveBeenCalledWith('new-stars', '0');
    expect(core.setOutput).toHaveBeenCalledWith('lost-stars', '0');
    expect(initializeDataBranch).not.toHaveBeenCalled();
  });

  describe('email', () => {
    const emailConfig = {
      host: 'smtp.test.com',
      port: 587,
      username: 'user',
      password: 'pass',
      to: 'to@test.com',
      from: 'from@test.com',
    };

    it('sends email when changes are detected', async () => {
      vi.mocked(getEmailConfig).mockReturnValue(emailConfig);

      await trackStars();

      expect(sendEmail).toHaveBeenCalledWith(
        expect.objectContaining({ emailConfig, htmlBody: '<p>HTML</p>' }),
      );
    });

    it('sends email when no changes but sendOnNoChanges is true', async () => {
      vi.mocked(loadConfig).mockReturnValue({ ...defaultConfig, sendOnNoChanges: true });
      vi.mocked(compareStars).mockReturnValue({
        ...defaultResults,
        summary: { ...defaultSummary, changed: false },
      });
      vi.mocked(getEmailConfig).mockReturnValue(emailConfig);

      await trackStars();

      expect(sendEmail).toHaveBeenCalled();
    });

    it('skips email when no changes and sendOnNoChanges is false', async () => {
      vi.mocked(compareStars).mockReturnValue({
        ...defaultResults,
        summary: { ...defaultSummary, changed: false },
      });
      vi.mocked(getEmailConfig).mockReturnValue(emailConfig);

      await trackStars();

      expect(sendEmail).not.toHaveBeenCalled();
      expect(core.info).toHaveBeenCalledWith('No star changes detected, skipping email');
    });

    it('skips email when threshold is not reached', async () => {
      vi.mocked(loadConfig).mockReturnValue({ ...defaultConfig, notificationThreshold: 10 });
      vi.mocked(shouldNotify).mockReturnValue(false);
      vi.mocked(getEmailConfig).mockReturnValue(emailConfig);

      await trackStars();

      expect(sendEmail).not.toHaveBeenCalled();
      expect(core.setOutput).toHaveBeenCalledWith('should-notify', 'false');
    });

    it('sends email when threshold is reached', async () => {
      vi.mocked(loadConfig).mockReturnValue({ ...defaultConfig, notificationThreshold: 5 });
      vi.mocked(shouldNotify).mockReturnValue(true);
      vi.mocked(getEmailConfig).mockReturnValue(emailConfig);

      await trackStars();

      expect(sendEmail).toHaveBeenCalled();
      expect(core.setOutput).toHaveBeenCalledWith('should-notify', 'true');
    });

    it('skips email when getEmailConfig returns null', async () => {
      vi.mocked(getEmailConfig).mockReturnValue(null);

      await trackStars();

      expect(sendEmail).not.toHaveBeenCalled();
    });

    it('catches email errors and logs a warning', async () => {
      vi.mocked(getEmailConfig).mockReturnValue(emailConfig);
      vi.mocked(sendEmail).mockRejectedValue(new Error('SMTP timeout'));

      await trackStars();

      expect(core.warning).toHaveBeenCalledWith('Failed to send email: SMTP timeout');
      expect(core.setFailed).not.toHaveBeenCalled();
    });
  });

  describe('error handling', () => {
    it('calls setFailed on top-level error', async () => {
      vi.mocked(loadConfig).mockImplementation(() => {
        throw new Error('config broken');
      });

      await trackStars();

      expect(core.setFailed).toHaveBeenCalledWith('Star Tracker failed: config broken');
    });

    it('logs stack trace on error via debug', async () => {
      const err = new Error('boom');
      err.stack = 'Error: boom\n    at test.ts:1';
      vi.mocked(loadConfig).mockImplementation(() => {
        throw err;
      });

      await trackStars();

      expect(core.debug).toHaveBeenCalledWith('Error: boom\n    at test.ts:1');
    });

    it('runs cleanup even when the callback throws', async () => {
      vi.mocked(readHistory).mockImplementation(() => {
        throw new Error('read failed');
      });

      await trackStars();

      expect(cleanup).toHaveBeenCalledWith('.star-data');
    });
  });

  describe('outputs', () => {
    it('sets all 7 outputs correctly', async () => {
      await trackStars();

      expect(core.setOutput).toHaveBeenCalledWith('report', '# MD Report');
      expect(core.setOutput).toHaveBeenCalledWith('report-html', '<p>HTML</p>');
      expect(core.setOutput).toHaveBeenCalledWith('total-stars', '100');
      expect(core.setOutput).toHaveBeenCalledWith('stars-changed', 'true');
      expect(core.setOutput).toHaveBeenCalledWith('new-stars', '12');
      expect(core.setOutput).toHaveBeenCalledWith('lost-stars', '2');
      expect(core.setOutput).toHaveBeenCalledWith('should-notify', 'true');
    });

    it('sets default outputs for empty repos', async () => {
      vi.mocked(getRepos).mockResolvedValue([]);

      await trackStars();

      expect(core.setOutput).toHaveBeenCalledWith(
        'report',
        'No repositories matched the configured filters.',
      );
      expect(core.setOutput).toHaveBeenCalledWith(
        'report-html',
        '<p>No repositories matched the configured filters.</p>',
      );
      expect(core.setOutput).toHaveBeenCalledWith('should-notify', 'false');
    });
  });

  describe('data flow', () => {
    it('passes maxHistory from config to addSnapshot', async () => {
      vi.mocked(loadConfig).mockReturnValue({ ...defaultConfig, maxHistory: 26 });

      await trackStars();

      expect(addSnapshot).toHaveBeenCalledWith(expect.objectContaining({ maxHistory: 26 }));
    });

    it('updates starsAtLastNotification when notifying', async () => {
      vi.mocked(shouldNotify).mockReturnValue(true);

      await trackStars();

      expect(writeHistory).toHaveBeenCalledWith(
        expect.objectContaining({
          history: expect.objectContaining({ starsAtLastNotification: 100 }),
        }),
      );
    });

    it('does not update starsAtLastNotification when threshold not reached', async () => {
      vi.mocked(shouldNotify).mockReturnValue(false);
      vi.mocked(compareStars).mockReturnValue({
        ...defaultResults,
        summary: { ...defaultSummary, changed: true },
      });

      await trackStars();

      expect(writeHistory).toHaveBeenCalledWith(
        expect.objectContaining({
          history: expect.not.objectContaining({ starsAtLastNotification: expect.anything() }),
        }),
      );
    });

    it('passes notificationThreshold to shouldNotify', async () => {
      vi.mocked(loadConfig).mockReturnValue({ ...defaultConfig, notificationThreshold: 'auto' });

      await trackStars();

      expect(shouldNotify).toHaveBeenCalledWith(expect.objectContaining({ threshold: 'auto' }));
    });

    it('includes delta indicator in commit message', async () => {
      vi.mocked(deltaIndicator).mockReturnValue('+10');

      await trackStars();

      expect(commitAndPush).toHaveBeenCalledWith(
        expect.objectContaining({
          message: expect.stringContaining('+10'),
        }),
      );
    });
  });
});
